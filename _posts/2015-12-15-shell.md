---
layout: post
title: "Somethign about Shell"
date: 2015-12-15 00:12:34 +0800
categories: shell
------

 [转载自：]<http://blog.csdn.net/anders_zhuo/article/details/8644207>

	#!/bin/bash
	echo -n "Enter your name:"
	read
	echo "read without anyvariables:REPLY=$REPLY"
	echo -n "Enter your age:"
	read age
	echo "read with variable:Age=$age and REPLY=$REPLY"

	echo "which one are you skilledin?"
	select var in "shell" "java" "c++" "c" "php" "c#"
	do
    	echo "the \$REPLY=$REPLY"
    	echo "you are skilled in $var"
    	break
	done

	count=1
	MAX=5	
	while [ "$SECONDS" -le "$MAX" ]
	do
    	echo "this is the $count time to sleep!"
    	let count=$count+1
    	sleep 2
	done
	echo "this script runs $SECONDS seconds!"

	# strlen(str) ${#str} or exptr length $string

	# expr index $string $substring
	# expr index "Speeding up small jobs in Hadoop" jobs
	# 0x13

	# get substring	
	#{string:position:length} 
	#{...} # 从零开始标记字符串 from left to right

	#{string: -position} #冒号和横杆之间有空格 从右边开始取
	#{string:(position)} 
	expr substr $string $position $length #从名称为$string的字符串的第#position位置开始		取长度为$length的子串

	delete sunstring
	${string#substring} #删除string开头处与substring匹配的最短子串
	${string##substring} #删除string子串与substring匹配的最长子串
	${string%substring} #删除string结尾处与substring匹配的最短子串
	${string%%substring} #删除string结尾处与substring匹配的最长子串

	
	eg
	定义一个字符串   20121114ReadingHadoop
	ming@ming-F83VF:~/shellpractice/chapter9$anotherstr=20121114ReadingHadoop
	ming@ming-F83VF:~/shellpractice/chapter9$echo $anotherstr
	20121114ReadingHadoop
	删除开头处 以 2开始1结尾的  最短字符串！！
	ming@ming-F83VF:~/shellpractice/chapter9$echo ${anotherstr#2*1}
	21114ReadingHadoop
	删除开头处 以 2开始1结尾的  最长字符串！！
	ming@ming-F83VF:~/shellpractice/chapter9$echo ${anotherstr##2*1}
	4ReadingHadoop
	删除结尾处 以 a开始p结尾的  最短字符串！！
	ming@ming-F83VF:~/shellpractice/chapter9$echo ${anotherstr%a*p}
	20121114ReadingH
	删除结尾处 以 a开始p结尾的  最长字符串！！
	ming@ming-F83VF:~/shellpractice/chapter9$echo ${anotherstr%%a*p}
	20121114Re

	5 替换子串
	替换子串命令都是${…}格式，可以在任意处、开头处和结尾处替换满足条件的子串
	${string/substring/replacement}    #仅替换第一次与substring相匹配的子串  
 	${string//substring/replacement}   #替换所有与substring相匹配的子串  
	${string/#substring/replacement}   #替换string开头处与substring相匹配的子串  
 	${string/%substring/replacement}   #替换string结尾处与substring相匹配的子串  

## IO重定向

		I/O重定向是一个过程，这个过程捕捉一个文件、或命令、或程序、或脚本、甚至代码块（code block）的输出，然后把捕捉到的输出，作为输入发送给另外一个文件、或命令、或程序、或脚本
		
		文件标识符是从0开始到9结束的整数，指明了与进程相关的特定数据流的源
		
		Linux系统启动一个进程（该进程可能用于执行Shell命令）时，将自动为该进程打开三个文件：标准输入、标准输出和标准错误输出，分别由文件标识符0、1、2标识

		Shell命令从标准输入读取输入数据，将输出送到标准输出，如果该命令在执行过程中发生错误，则将错误信息输出到标准错误输出，默认情况下，标准输入与键盘输入相关联，标准输出和标准错误输出与显示器相关联
	"" 标准输出： ""
	例1
		cat和>符号结合成为简易文本编辑器
		cat命令后不加任何参数时，cat命令的输入是标准输入，即键盘输入
		利用I/O重定向符号“>”将键盘输入写入文件
		cat > newfile后，就可输入需要写到newfile的内容，最后按CTRL+D结束对newfile的编辑

	例2
		>>符号用于在已有文件后追加一些文本
		eg
		ls >>newfile  只是追加并没有把原来的覆盖掉
		ls >newfile   将文件清空，然后将内容写进去

	例3
		>|符号是强制覆盖文件的符号，它与Shell的noclobber选项有关系，如果noclobber选项开启，表		示不允许覆盖任何文件，而>|符号则可以不管noclobber选项的作用，强制将文件覆盖
		eg
		ming@ming-F83VF:~/shellpractice/chapter10$set -C  noclobber选项开启
		ming@ming-F83VF:~/shellpractice/chapter10$date >newfile
		bash: newfile: 无法覆盖已存在的文件

		ming@ming-F83VF:~/shellpractice/chapter10$date >|newfile
		ming@ming-F83VF:~/shellpractice/chapter10$cat newfile
		2012年 11月 10日 星期日 09:47:25 CST

### 标准错误输出：
	1
	重定向标准错误输出，需要使用文件标识符2
 	2> newfile
 	
 	eg 
	ming@ming-F83VF:~/shellpractice/chapter10$ ls 22*>newfile 此时是将标准输出到	newfile中  但是屏幕中还是会输出，因为他是标准输出 
	ls: 无法访问22*: 没有那个文件或目录
	ming@ming-F83VF:~/shellpractice/chapter10$ls 22* 2>newfile 
	此时是将标准错误输出到	newfile中所以屏幕中没有任何输出
	ming@ming-F83VF:~/shellpractice/chapter10$cat newfile
	ls: 无法访问22*: 没有那个文件或目录
	
	2
	< 是I/O重定向的输入符号，它可将文件内容写到标准输入之中
 
	ming@ming-F83VF:~/shellpractice/chapter10$ wc -l <newfile
	1
	这个newfile作为标准输入到wc 所以wc得到的内容只是newfile的内容！！
	所以他不会知道这是哪个文件！所以只是打印出了文件行数
 
	ming@ming-F83VF:~/shellpractice/chapter10$wc -l newfile
	1 newfile
	这个newfile作为wc命令的 操作文件。此时wc知道他要计数的是哪个文件，所以能打印出newfile文件名，因此既打印出了行数也打印出了文件名
 
	<<delimiter  这个比较重要！！！
	符号称为此处文档（Here-document），delimiter称为分界符，该符号表明：Shell将分界符delimiter之后直至下一个delimiter之前的所有内容作为输入
 
	ming@ming-F83VF:~/shellpractice/chapter10$cat >newfile <<CLOUD
	> hello cloud
	> hadoop
	> nosql
	> CLOUD
	(剖析：cat>newfile 是将标准输入到newfile文件中，即键盘输入newfile<<CLOUD是将输入到CLOUD之前的内容作为标准输入在此之前是用ctrl+d 结束标准输入，而使用<<  则是吧CLOUD作为结束标准输入)
 
	ming@ming-F83VF:~/shellpractice/chapter10$cat newfile
	hello cloud
	hadoop
	nosql
